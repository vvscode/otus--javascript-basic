<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 26</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />


    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section  data-markdown><script type="text/template">

### Разбор базовых приемов разработки на Typescript

</script></section><section ><section data-markdown><script type="text/template">

### Типы и интерфейсы

</script></section><section data-markdown><script type="text/template">

Базовые типы:

- string
- number
- boolean
- void
- unknown
- symbol
- any
- null / undefined
- never

</script></section><section data-markdown><script type="text/template">

Базовые типы:

- array
- tuple (кортеж)
- enum
- object
- function

</script></section><section data-markdown><script type="text/template">

Литеральные типы

```ts [1-30]
type Yes = "yes";
type Zero = 0;
```

</script></section><section data-markdown><script type="text/template">

Литеральные типы

```ts [1-30]
type Yes = "yes";
let answer: Yes = "no"; // ERROR Type '"no"' is not assignable to type '"yes"'

type Zero = 0;
let result: Zero = 1; // ERROR Type '1' is not assignable to type '0'
```

</script></section><section data-markdown><script type="text/template">

Массивы  
_между этими вариантами нет разницы_

- `number[]`
- `Array<number>`

</script></section><section data-markdown><script type="text/template">

Явные/Неявные типы  
_их поведение не отличается_

```ts [1-30]
let a = 1; // implicit
a = "one"; // ERROR Type 'string' is not assignable to type 'number'

let b: number = 1;
b = "one"; // ERROR Type 'string' is not assignable to type 'number'
```

</script></section><section data-markdown><script type="text/template">

Object types

```ts [1-30]
type Coord = {
  x: number;
  y: number;
};
```

</script></section><section data-markdown><script type="text/template">

Object types

```ts [1-30]
type Coord = { x: number; y: number };

type Square = {
  leftTop: Coord;
  rightBottom: Coord;
};
```

</script></section><section data-markdown><script type="text/template">

Не обязательные поля обозначают `?`

```ts [1-30]
type Coord = {
  x: number;
  y: number;
  timestamp?: number;
};
```

</script></section><section data-markdown><script type="text/template">

Типы для функций

```ts [1-30]
function getNameLength(name: string): number {
  return name ? name.length : 0;
}

// опциональные параметры помечаются `?`
function getOptionalNameLength(name?: string): number {
  return name ? name.length : 0;
}
```

</script></section><section data-markdown><script type="text/template">

Декларация функций

```ts [1-30]
let cb1: Function = (a: number) => a * 2;

let cb2: (a: number) => number = (a) => a * 2;

// Тип можно сужать
let cb3: (a: number) => number = () => 2;

// Но нельзя расширять
// ERROR Type '(a: number) => number' is not assignable to type '() => number'.
let cb4: () => number = (a: number) => a * 2;
```

</script></section><section data-markdown><script type="text/template">

Декларация функций  
_типизация контекста_

```ts [1-30]
// возможность задать тип для контекста
function x(this: number[], a: number) {
  return this.includes(a);
}
```

</script></section><section data-markdown><script type="text/template">

Т.к. Javascript это язык с динамической типизацией, TS для поддержки всего многообразия поддерживает перегрузку функций (и методов).

Мы можем объявить несколько сигнатур, и одну реализацию (которая должна учитывать все сигнатуры).

```ts [1-30]
function sum(a: string, b: string): string;
function sum(a: number, b: number): number;
function sum(a: any, b: any) {
  return a + b;
}

const x = sum(1, 2);
const y = sum("a", "b");
```

</script></section><section data-markdown><script type="text/template">

Мы можем использовать тут generic. Но **не можем** использовать сигнатуру реализации `number|string`

```ts [1-30]
function sum(a: number | string, b: number | string) {
  return a + b;
}
```

Понятно ли почему?

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section><section data-markdown><script type="text/template">

**Приведение типов**

Иногда вы знаете про тип больше, чем знает Typescript. Например - вы точно знаете про значение, которое относится к более широкому типу. Чтобы указать больше конкретики вы можете использовать ключевое слово `as`.

```ts [1-30]
let someData: any = "1234";

let id: string | number | null = someData;

// id.length <--
(id as string).length;
```

</script></section><section data-markdown><script type="text/template">

Подобным образом мы уже действовали, когда делали

```ts [1-30]
const el = document.querySelector("#app") as HTMLElement;
```

</script></section><section data-markdown><script type="text/template">

У вас есть возможность объявлять объекты неизменяемыми c помощью `as const`.

```ts [1-30]
const obj = {
  a: 1,
  b: 2,
  c: {
    d: 3,
    e: 4,
  },
} as const;
```

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
// с помощью магии можно сделать тип readonly на любую глубину
type DeepReadonly<T> = T extends (infer R)[]
  ? DeepReadonlyArray<R>
  : T extends Function
  ? T
  : T extends object
  ? DeepReadonlyObject<T>
  : T;

interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}

type DeepReadonlyObject<T> = {
  readonly [P in keyof T]: DeepReadonly<T[P]>;
};
```

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section><section data-markdown><script type="text/template">

[Еще немного базовых типов:](https://www.typescriptlang.org/docs/handbook/basic-types.html#unknown)

- `any` - любой тип (отключает проверки typescript)
- `never` - тип который никогда не встречается _(является подтипом любого типа, однако ни один тип не является его подтипом)_
- `unknown` - любой тип, о котором мы не знаем (обычно касается динамических данных, может сужаться к любому типу явным приведением)
- `void` - отсутствие типа

</script></section><section data-markdown><script type="text/template">

В паре с приведением это позволяет делать например `force cast`.

```ts [1-30]
const a = 1 as unknown as string;
console.log(a.length); // что будет в консоли?
```

Бывает полезно в тестах. В рабочем коде лучше использовать [пользовательские type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)

</script></section><section data-markdown><script type="text/template">

Более сложный пример с дженериком

```ts [1-30]
function castTo<T>(x: unknown) {
  return x as T;
}

let x: string = castTo<string>(123);
console.log(x.length);
```

Бывает полезно в тестах. В рабочем коде лучше использовать [пользовательские type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)

</script></section><section data-markdown><script type="text/template">

Кортежи (типизированные списки)

позволяет определить список с фиксированным размером и известными типами элементов

```ts [1-30]
type Coord = [number, number];
```

</script></section><section data-markdown><script type="text/template">

[Типы-объединения](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

```ts [1-30]
type Id = number | string;

// Вместе с литеральными типами
type Direction = "left" | "right" | "up" | "down";
```

</script></section><section data-markdown><script type="text/template">

[Перечисления](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums)

```ts [1-30]
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
```

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
enum Direction {
  Up = 1,
  Down,
  Left,
  Right,
}
```

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
enum Direction {
  Up = "Up",
  Down = "Down",
  Left = "Left",
  Right = "Right",
}
```

</script></section><section data-markdown><script type="text/template">

По умолчанию поддерживают [reverse mapping](https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings).

Для отключения транспиляции в JS [используют `const enums`](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)

</script></section><section data-markdown><script type="text/template">

[Номинальные типы данных](https://ru.qaz.wiki/wiki/Nominal_type_system)

- это подход, когда [сравнение типов делается на основе имени](<https://typescript-definitive-guide.ru/book/chapters/Sovmestimost_tipov_na_osnove_vida_tipizacii#Nominativnaya_Tipizaciya_(nominative_typing)>).

В Typescript принята [структурная типизация](<https://typescript-definitive-guide.ru/book/chapters/Sovmestimost_tipov_na_osnove_vida_tipizacii#Strukturnaya_Tipizaciya_(structural_typing)>)

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
type UserId = number | string;
type BookId = number | string;

const bobId: UserId = 3;
const bibleId: BookId = bobId; // <-- иногда мы хотим это исключить
```

</script></section><section data-markdown><script type="text/template">

В Typescript нет номинальных типов, но [их можно создать](https://basarat.gitbook.io/typescript/main-1/nominaltyping).

```ts [1-30]
type BrandedType<BaseType, BrandName extends string> = BaseType & {
  _: BrandName;
};

type Id = number | string;
type UserId = BrandedType<Id, "user">;
type BookId = BrandedType<Id, "book">;

let bobId: UserId = 5 as UserId;
let bookId: BookId = bobId;
```

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section><section data-markdown><script type="text/template">

[Типы и интерфейсы](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases)

- Почти все возможности интерфейсов доступны с типами (type aliases)
- **Типы не могут наследовать другие типы, а интерфейс может наследовать другой тип или интерфейс, добавляя, таким образом, новые свойства**
- [Типы не могут декларативно объединяться, а интерфейсы могут](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)
- Поскольку интерфейсы больше похожи на поведение объектов в Javascript, **рекомендуется отдавать предпочтение интерфейсам**
- Типы подходят, если вы не можете выразить какую-то форму с помощью интерфейса или вам нужны кортежи или объединения

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
// пример определения функции через интерфейс
interface Double {
  (a: number): number;
}

const double: Double = (x) => x * 2;
```

</script></section><section data-markdown><script type="text/template">

```ts [1-30]
// пример наследования интерфейсов
interface Human {
  name: string;
  email: string;
}

interface Student extends Base {
  averageRate: number;
}

const kotov: Student = {
  name: "Василий Котов",
  email: "kotov@gmail.com",
  averageRate: 4.6,
};
```

</script></section><section data-markdown><script type="text/template">

<a href="https://cqx92skly5b.typeform.com/to/mrwZgwbc" target="_blank">ОПРОС</a>
<a href="https://admin.typeform.com/form/mrwZgwbc/results#insights" target="_blank"><img src="./images/mrbean.jpg"></a><br>

</script></section></section><section  data-markdown><script type="text/template">

Дополнительные материалы:

- [Номинативная типизация в TypeScript или как защитить свой интерфейс от чужих идентификаторов](https://habr.com/ru/post/446768/)
- [Typescript Глубокое Погружение](https://igorfonin.gitbook.io/typescript-book-ru/) ([ссылки на скачивание](https://github.com/etroynov/typescript-book))
- [TypeScript крупным планом](https://typescript-definitive-guide.ru/)
- [Перевод официальной документации Typescript на русский](http://typescript-lang.ru/docs/) _(немного устаревшая, но удобная для чтения)_
- Шпаргалки по Typescript - [1](https://devhints.io/typescript) и [2](https://www.sitepen.com/blog/typescript-cheat-sheet)
</script></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%","tableofcontents":{"title":"План","position":1000}}, queryOptions);
    </script>

    <script src="./../_assets/plugins.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
