<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 35</title>
    <link rel="shortcut icon" href="./../favicon.ico"/>
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />

    <script>
      document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

## REST, RPC и работа с внешними API

</script></section><section data-markdown><script type="text/template">

### План вебинара:

- Request–Response APIs
- fetch vs XHR
- правила REST
- сторонние апи
</script></section></section><section ><section data-markdown><script type="text/template">

### Request–Response APIs

</script></section><section data-markdown><script type="text/template">

#### Основные свойства Request–Response API

- API предоставляется посредством HTTP веб сервера
- API предоставляет набор эндпоинтов
- клиент делает http запрос **request** на нужные эндпоинты и получает ответ **response**
- response обычно в формате JSON или XML
</script></section><section data-markdown><script type="text/template">

#### Самые распространенные request-response API

- REST
- RPC
- GraphQL
</script></section></section><section ><section data-markdown><script type="text/template">

### REST

</script></section><section data-markdown><script type="text/template">

_Representational State Transfer (REST)_ - самый популярный подход для разработки API в наше время

Применяется такими компаниями, как Google, Stripe, Twitter, Github и т.д.

</script></section><section data-markdown><script type="text/template">

REST - это про resources и методы работы с этими ресурсами

**Resource** - это объект, который может быть идентифицирован, назван, адресован или обработан в сети.

</script></section><section data-markdown><script type="text/template">

REST представляет данные в виде ресурсов и использует стандартные методы HTTP для представления операций над этими ресурсами

</script></section><section data-markdown><script type="text/template">

#### Примеры ресурсов

[Stripe API](https://stripe.com/docs/api) представляет пользователей (customers), расходы (charges), платежный баланс (balance), возмещение денежных средств (refunds), события (events), файлы (files) и выплаты (payouts) как ресурсы.

</script></section><section data-markdown><script type="text/template">

#### Некоторые общие правила, которым следуют REST API:

</script></section><section data-markdown><script type="text/template">

Ресурсы являются частью URL-адресов, например **/users**

</script></section><section data-markdown><script type="text/template">

Для каждого ресурса обычно реализуются два URL-адреса: один для коллекции, например **/users**, и один для определенного элемента, например **/users/U123**

</script></section><section data-markdown><script type="text/template">

Существительные вместо глаголов. Например, вместо **/getUserInfo/U123** используется **/users/U123**

</script></section><section data-markdown><script type="text/template">

- **C**reate - используйте POST для создания новых ресурсов
- **R**ead - используйте GET для чтения ресурсов. Запросы GET никогда не изменяют состояние ресурса. У них нет побочных эффектов; метод GET имеет семантику только для чтения. GET идемпотентен. Следовательно, вы можете кэшировать вызовы.
- **U**pdate - используйте PUT для замены ресурса и PATCH для частичного обновления существующих ресурсов.
- **D**elete - используйте DELETE для удаления существующих ресурсов.
  </script></section><section data-markdown><script type="text/template">
  Стандартные коды состояния ответа HTTP возвращаются сервером, указывая на успех или неудачу.
- **2XX** успех
- **3XX** перемещение ресурса
- **4XX** ошибки на стороне клиента (например, отсутствие обязательного параметра или слишком много запросов)
- **5XX** ошибки на стороне сервера
  </script></section><section data-markdown><script type="text/template">
  CRUD операции, HTTP глаголы и REST соглашения

<img src="./images/REST_CRUD_operations.png" alt="CRUD операции, HTTP глаголы, and REST соглашения">
  </script></section><section data-markdown><script type="text/template">
  HTTP-запрос для получение платежа через Stripe API

```
GET /v1/charges/ch_CWyutlXs9pZyfD
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

HTTP-запрос для создание списания средств через Stripe API

```
POST /v1/charges
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

</script></section><section data-markdown><script type="text/template">

Ресурс, который может существовать только в другом ресурсе, должен быть представлен как сабресурс, а не как ресурс верхнего уровня в URL-адресе.

</script></section><section data-markdown><script type="text/template">

Например, GitHub API использует сабресурсы для представления отношений в различных API:

<div style="text-align: left"> Создать issue</div>

```
POST /repos/:owner/:repo/issues
```

<div style="text-align: left"> Получить определенный issue</div>

```
GET /repos/:owner/:repo/issues/:number
```

<div style="text-align: left"> Получить все issue</div>

```
GET /repos/:owner/:repo/issues
```

<div style="text-align: left"> Изменить issue</div>

```
PATCH /repos/:owner/:repo/issues/:number
```

</script></section><section data-markdown><script type="text/template">

А что если нужно больше 4 видов операций? Например, архивировать репозиторий
<img src="./images/Archive_repo.png" alt="Архивировать репозиторий">

</script></section><section data-markdown><script type="text/template">

Помимо типичных операций CRUD, которые мы только что рассмотрели, API REST иногда может потребовать представления операций, не относящихся к CRUD. В этом случае обычно используются следующие подходы:

</script></section><section data-markdown><script type="text/template">

#### Действие как часть поля ресурса

API GitHub использует флаг **archive** в качестве входного параметра для API редактирования репозитория, чтобы представить действие архивирования репозитория

```console
PATCH /repos/vvscode/otus--javascript-basic
HOST api.github.com
Content-Type: application/json
Authorization: token OAUTH-TOKEN
{
  "archived": true
}
```

</script></section><section data-markdown><script type="text/template">

#### Действию как саб - ресурс

API GitHub использует этот шаблон для блокировки и разблокировки проблемы.

```console
PUT /repos/:owner/:repo/issues/:number/lock
```

</script></section><section data-markdown><script type="text/template">

Некоторые операции, такие как поиск, еще сложнее вписать в парадигму REST. Типичная практика в этом случае - использовать только команду действия в URL-адресе API.

```console
GET /search/code?q=:query:
```

Пример поиска файлов в GitHub, соответствующих заданному запросу.

</script></section></section><section ><section data-markdown><script type="text/template">

### Remote Procedure Call

</script></section><section data-markdown><script type="text/template">

**Удаленный вызов процедур (RPC)** - это одна из простейших парадигм API, в которой клиент выполняет блок кода на другом сервере.

</script></section><section data-markdown><script type="text/template">

В то время как **REST** рассматривает ресурсы, RPC касается действий. Клиенты обычно передают имя метода и аргументы серверу и получают обратно JSON или XML.

</script></section><section data-markdown><script type="text/template">

API RPC обычно следуют двум простым правилам:

- endpoint-ы содержат имя выполняемой операции
- вызовы API выполняются с помощью наиболее подходящего HTTP-глагола: GET для запросов чтения и POST для других
  </script></section><section data-markdown><script type="text/template">
  Стиль RPC отлично подходит для API, которые предоставляют различные действия, которые могут иметь больше нюансов и сложностей, чем может быть инкапсулировано с помощью CRUD
  </script></section><section data-markdown><script type="text/template">
  Пример HTTP запроса к Slack API

```console
POST /api/conversations.archive
HOST slack.com
Content-Type: application/x-www-form-urlencoded
Authorization: Bearer xoxp-1650112-jgc2asDae
```

API позволяет выполнять несколько действий, таких как архивирование, присоединение, удаление, выход и переименование. Хотя в этом случае есть явный «ресурс», не все эти действия хорошо вписываются в шаблон REST.

</script></section><section data-markdown><script type="text/template">
<img src="./images/slack_conversation_API.png" alt="Slack conversation API">
</script></section></section><section ><section data-markdown><script type="text/template">

### GraphQL

</script></section><section data-markdown><script type="text/template">

GraphQL - это язык запросов для API, который в последнее время приобрел значительную популярность.

Он был разработан внутри Facebook в 2012 году до публичного выпуска в 2015 году и был принят поставщиками API, такими как GitHub, Yelp и Pinterest.

</script></section><section data-markdown><script type="text/template">

GraphQL позволяет клиентам определять структуру требуемых данных, и сервер возвращает именно эту структуру.

GraphQL query

```console
{
    user(login: "saurabhsahni") {
      id
      name
      company
      createdAt
    }
}
```

Response from GitHub GraphQL API

```console
{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjY1MDI5",
      "name": "Saurabh Sahni",
      "company": "Slack",
      "createdAt": "2009-03-19T21:00:06Z"
    }
  }
}
```

</script></section><section data-markdown><script type="text/template">

В отличие от REST и RPC API, GraphQL API требует только одну конечную точку URL. Точно так же вам не нужны разные HTTP-команды для описания операции. Вместо этого вы указываете в теле JSON, выполняете ли вы запрос или мутацию.

</script></section><section data-markdown><script type="text/template">

#### GraphQL имеет несколько ключевых преимуществ перед REST и RPC:

</script></section><section data-markdown><script type="text/template">

GraphQL позволяет вкладывать запросы друг в друга и запрашивать данные с разных источников за один запрос. Без GraphQL может понадобиться множество HTTP вызовов на сервер.

</script></section><section data-markdown><script type="text/template">

**Нет управления версиями**  
Вы можете добавлять новые поля и типы в GraphQL API, не затрагивая существующие запросы. Точно так же проще отказаться от использования существующих полей.

</script></section><section data-markdown><script type="text/template">

**Ничего лишнего**  
Благодаря GraphQL, поскольку клиенты могут точно указать, что им нужно, размеры полезной нагрузки могут быть меньше.

</script></section><section data-markdown><script type="text/template">

**Строго типизированный**  
GraphQL строго типизирован. Во время разработки проверка типов GraphQL помогает гарантировать, что запрос синтаксически верен и действителен.

</script></section><section data-markdown><script type="text/template">

**Самодокументированность**  
Хотя существуют внешние решения, такие как Swagger, которые помогают упростить изучение REST API, в GraphQL изначально поставляется с GraphQL, встроенной в браузер IDE для изучения GraphQL.

</script></section><section data-markdown><script type="text/template">

#### Что, одни плюсы?!

</script></section><section data-markdown><script type="text/template">

#### Минусы:

- Хотя GraphQL имеет множество преимуществ, одним из его недостатков является сложность, которую он добавляет поставщику API.
- Серверу требуется дополнительная обработка для анализа сложных запросов и проверки параметров.
- Оптимизация производительности запросов GraphQL тоже может быть сложной задачей.

</script></section><section data-markdown><script type="text/template">

Для внутренних нужд компании легко предсказать варианты использования и отладить узкие места в производительности. При работе с внешними разработчиками эти варианты использования становятся трудными для понимания и оптимизации.

</script></section><section data-markdown><script type="text/template">

#### Резюмируем

<img src="./images/comparision2.png" alt="Сводная таблица различий 3 подходов">

</script></section></section><section ><section data-markdown><script type="text/template">

### XMLHttpRequest vs fetch

</script></section><section data-markdown><script type="text/template">

Следующий код JavaScript показывает базовый HTTP-запрос GET для http://www.7timer.info с использованием XMLHttpRequest (обычно сокращается до XHR):

```javascript
const xhr = new XMLHttpRequest();
xhr.open(
  "GET",
  "https://www.7timer.info/bin/astro.php?lon=113.2&lat=23.1&output=json"
);
// Подписываемся на изменение состояния запроса
xhr.onreadystatechange = function () {
  // Проверка, завершилось ли выполнение запроса?
  if (xhr.readyState !== 4) return;

  if (xhr.status === 200) {
    // Обработка удачного выполнения запроса
    console.log(xhr.responseText);
  } else {
    // Обработка ошибки
    console.log("HTTP error", xhr.status, xhr.statusText);
  }
};
// Отправляем запрос
xhr.send();
```

</script></section><section data-markdown><script type="text/template">

Объект XMLHttpRequest имеет много других параметров, событий и свойств ответа. Например, тайм-аут в миллисекундах может быть установлен и обнаружен:

```javascript
// установка timeout
xhr.timeout = 3000; // 3 секунды
xhr.ontimeout = () => console.log("timeout", xhr.responseURL);
```

</script></section><section data-markdown><script type="text/template">

и событие progress может сообщить о длительной загрузке файла:

```javascript
xhr.upload.onprogress = (p) => {
  console.log(Math.round((p.loaded / p.total) * 100) + "%");
};
```

</script></section><section data-markdown><script type="text/template">

Также запрос XHR легко завершить с помощью `xhr.abort()` и, при необходимости, обнаружить такое событие с помощью функции `xhr.onabort`.

</script></section><section data-markdown><script type="text/template">

Число параметров может вызывать недоумение, и ранние реализации XMLHttpRequest имели несколько кросс-браузерных несоответствий. По этой причине большинство библиотек и сред предлагают функции-оболочки Ajax для решения этих проблем, например, метод jQuery.ajax():

```javascript
$.ajax("http://domain/service")
  .done((data) => console.log(data))
  .fail((xhr, status) => console.log("error:", status));
```

</script></section><section data-markdown><script type="text/template">

**Fetch** API является современной альтернативой XMLHttpRequest. Универсальные интерфейсы Headers, Request и Response обеспечивают согласованность, в то время как Promises позволяют упростить цепочки и async/await без обратных вызовов.

</script></section><section data-markdown><script type="text/template">

Приведенный выше пример XHR можно преобразовать в гораздо более простой код на основе Fetch, который даже анализирует возвращенный JSON:

```javascript
fetch("http://domain/service", { method: "GET" })
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.error("error:", error));
```

</script></section><section data-markdown><script type="text/template">

Fetch - чистый, элегантный и простой для понимания. Почему бы нам не использовать его вместо древнего XMLHttpRequest?

</script></section><section data-markdown><script type="text/template">

Fetch API достаточно хорошо поддерживается, но он не будет работать во всех выпусках Internet Explorer. Люди, использующие версии Chrome, Firefox и Safari старше 2017 года, также могут испытывать проблемы.

</script></section><section data-markdown><script type="text/template">

Удивительно, но ошибка HTTP, такая как **404 Page Not Found** или **500 Internal Server Error**, не попадет в `.catch()`. Обычно он разрешается с состоянием response.ok, установленным в false.

</script></section><section data-markdown><script type="text/template">

#### Отмена запроса

Прекращение отправки было невозможно в течение нескольких лет, но теперь оно поддерживается в браузерах, которые реализуют API `AbortController`. Это запускает сигнал, который может быть передан объекту инициации Fetch:

```javascript
const controller = new AbortController();
fetch("http://domain/service", {
  method: "GET",
  signal: controller.signal,
})
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.error("Error:", error));
```

Обработка может быть прервана вызовом controller.abort(). Будет вызвана функция `.catch()`.

</script></section><section data-markdown><script type="text/template">

#### Нет прогресса

На момент написания, Fetch не поддерживает события прогресса. Поэтому невозможно сообщить о статусе загрузки файлов или аналогичных представлений больших форм.

</script></section></section><section ><section data-markdown><script type="text/template">

### Рассмотрим REST поближе

</script></section><section data-markdown><script type="text/template">

**что значит RESTful**

- Client-Server
- Stateless
- Cache
- Uniform Interface
- Layered System
- Code-On-Demand (опционально)
</script></section><section data-markdown><script type="text/template">

#### Client-Server

- **клиенты** не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается
- **серверы** не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы
</script></section><section data-markdown><script type="text/template">

#### Stateless

Сервер не должен хранить какой-либо информации о клиентах и последних запросах. Каждый запрос - как новый. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента. No session, no history.

</script></section><section data-markdown><script type="text/template">

#### Cache

Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.

</script></section><section data-markdown><script type="text/template">

#### Uniform Interface

- Identification of resources
- Manipulation of resources through representations
- Self-descriptive messages
- HATEOAS
</script></section><section data-markdown><script type="text/template">

#### Layered System

Многоуровневость достигается за счёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.

</script></section><section data-markdown><script type="text/template">

#### Code-On-Demand (опционально)

REST позволяет наращивать функциональность клиентского приложения по мере необходимости при помощи скачивания и исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, уменьшая количество заранее написанных возможностей.

</script></section></section><section ><section data-markdown><script type="text/template">

### OAuth

</script></section><section data-markdown><script type="text/template">
<img src="./images/oauth_example1.png" alt="Пример OAuth">
</script></section><section data-markdown><script type="text/template">
<img src="./images/oauth_example2.png" alt="Пример OAuth">
</script></section><section data-markdown><script type="text/template">
**OAuth 2.0** — протокол авторизации, позволяющий выдать одному сервису (приложению) права на доступ к ресурсам пользователя на другом сервисе.

- нет необходимости доверять логин и пароль
- выдаем ограниченный набор прав

</script></section><section data-markdown><script type="text/template">

Сначала определимся с терминами, что такое аутентификация/авторизация? Есть ли разница?

</script></section><section data-markdown><script type="text/template">

**Authentication** - процесс проверки того, кто вы есть. Веб-приложения обычно добиваются этого, предлагая вам войти в систему с именем пользователя и паролем.

</script></section><section data-markdown><script type="text/template">

**Authorization** - процесс подтверждения того, что вам разрешено делать то, что вы пытаетесь сделать.

</script></section><section data-markdown><script type="text/template">

При разработке API необходимо подумать о том, как разработчики приложений будут выполнять как аутентификацию, так и авторизацию с помощью вашего API.

</script></section><section data-markdown><script type="text/template">

Вначале поставщики API начали поддерживать **Basic Authentication**. Это простейший метод, используемый для обеспечения контроля доступа в Интернете.

</script></section><section data-markdown><script type="text/template">

Клиенты отправляют HTTP-запросы с заголовком **Authorization**, в качестве значения используется строка: `Basic user:password`. **`user:password`** кодируется с помощью base64

```console
Authorization: Basic dXNlcjpwYXNzd29yZA==
```

</script></section><section data-markdown><script type="text/template">

Если вы используете **Basic Authentication** для своего API, чтобы использовать приложение стороннего разработчика, вашим пользователям может потребоваться предоставить им свои учетные данные для имени пользователя и пароля. Почему это плохо?

</script></section><section data-markdown><script type="text/template">

Приложения должны хранить эти учетные данные в виде открытого текста или таким образом, чтобы они могли их расшифровать.

</script></section><section data-markdown><script type="text/template">

Пользователи не могут отозвать доступ к одному приложению, не отозвав доступ ко всем приложениям, изменив пароль.

</script></section><section data-markdown><script type="text/template">

Приложения получают полный доступ к учетным записям пользователей. Пользователи не могут ограничивать доступ к выбранным ресурсам.

</script></section><section data-markdown><script type="text/template">

По этим причинам Twitter решил прекратить поддержку **Basic Authentication** для своего основного API в 2010 году.

</script></section><section data-markdown><script type="text/template">

Самым большим преимуществом OAuth является то, что пользователям не нужно сообщать приложениям пароли. Рассмотрим пример.

</script></section><section data-markdown><script type="text/template">

Предположим, что TripAdvisor хочет создать приложение, которое будет использовать идентификационные данные пользователя Facebook, профиль, список друзей и другие данные Facebook.

</script></section><section data-markdown><script type="text/template">

С помощью OAuth TripAdvisor может перенаправить этого пользователя на Facebook, где он может разрешить TripAdvisor доступ к своей информации:

<img src="./images/ta1.png" alt="Пример TripAdvisor" width="600px">

После того, как пользователь разрешит совместное использование данных, TripAdvisor может вызвать API Facebook для получения этой информации.

</script></section></section><section ><section data-markdown><script type="text/template">

### Плюсы OAUTH

</script></section><section data-markdown><script type="text/template">

Пользователям не нужно сообщать приложениям пароли.

</script></section><section data-markdown><script type="text/template">

Второе преимущество OAuth заключается в том, что он позволяет пользователям поставщиков API предоставлять выборочные разрешения.

</script></section><section data-markdown><script type="text/template">

В прошлом примере TripAdvisor получит разрешение на чтение профиля пользователя, списка друзей и т.д., Но не может публиковать сообщения от имени пользователя в Facebook.

</script></section><section data-markdown><script type="text/template">

Наконец, если в какой-то момент пользователь захочет отозвать доступ TripAdvisor к своим данным в Facebook, он может просто зайти в свои настройки Facebook и отозвать его, не меняя пароль.

</script></section></section><section ><section data-markdown><script type="text/template">

### Флоу OAuth

</script></section><section data-markdown><script type="text/template">

С OAuth приложения используют токен доступа для вызова API от имени пользователя.

</script></section><section data-markdown><script type="text/template">

Получение токена происходит в три этапа:

</script></section><section data-markdown><script type="text/template">

Приложение направляет пользователя к провайдеру API для авторизации.
В приложениях обычно сначала отображается кнопка с надписью «Продолжить с Facebook».  
<img src="./images/oauth_example2.png" alt="Пример OAuth" width="400px">  
Когда пользователи нажимают кнопку, они перенаправляются на URL-адрес авторизации поставщика API.  
При перенаправлении приложение отправляет **clientId** и запрошенные разрешения(**scope**)

</script></section><section data-markdown><script type="text/template">

Поставщик API запрашивает авторизацию пользователя.  
Поставщик API должен четко указывать, какие разрешения запрашивает приложение.  
<img src="./images/requestScope.png" alt="Запрос на разрешение" width="400px">  
Если пользователь одобряет запрос, он перенаправляется обратно в приложение с кодом авторизации.

</script></section><section data-markdown><script type="text/template">

Приложение обменивает код авторизации на токен доступа **accessToken**.
<img src="./images/oauth_flow.png" alt="Запрос на разрешение" width="600px">

</script></section><section data-markdown><script type="text/template">

После того, как разработчики получили токен доступа, они могут начать делать запросы API, используя этот доступ, установив заголовок авторизации HTTP.

```console
POST /api/chat.postMessage
HOST slack.com
Content-Type: application/json
Authorization: Bearer xoxp-16501860-a24afg234
{
  ...
 }
```

</script></section><section data-markdown><script type="text/template">

При получении этих запросов серверам поставщиков API необходимо проверить две вещи.

</script></section><section data-markdown><script type="text/template">

- Во-первых, токен доступа действителен. Вам необходимо сопоставить данный токен доступа с предоставленными токенами доступа в вашей базе данных.
  </script></section><section data-markdown><script type="text/template">
  Во-вторых, токен доступа имеет необходимую область действия, которое должен выполнить запрос. Если какая-либо из проверок не удалась, сервер должен вернуть ошибку.

</script></section></section><section  data-markdown><script type="text/template">

Дополнительные материалы:

- [REST простым языком](https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78)
- [Получение данных с сервера](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data)
- [OAuth простым и понятным языком](https://habr.com/ru/company/mailru/blog/115163/)
</script></section><section  data-markdown><script type="text/template">

### Опрос о занятии
</script></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
