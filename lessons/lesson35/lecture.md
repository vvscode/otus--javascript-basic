---
title: Занятие 35
description: «REST, RPC и работа с внешними API»
---

# OTUS

## Javascript Basic

<!-- v -->

## REST, RPC и работа с внешними API

<!-- v -->

### План вебинара:

- Request–Response APIs
- fetch vs XHR
- правила REST
- сторонние апи
<!-- s -->

### Request–Response APIs

<!-- v -->

#### Основные свойства Request–Response API

- API предоставляется посредством HTTP веб сервера
- API предоставляет набор эндпоинтов
- клиент делает http запрос **request** на нужные эндпоинты и получает ответ **response**
- response обычно в формате JSON или XML
<!-- v -->

#### Самые распространенные request-response API

- REST
- RPC
- GraphQL
<!-- s -->

### REST

<!-- v -->

_Representational State Transfer (REST)_ - самый популярный подход для разработки API в наше время

Применяется такими компаниями, как Google, Stripe, Twitter, Github и т.д.

<!-- v -->

REST - это про resources и методы работы с этими ресурсами

**Resource** - это объект, который может быть идентифицирован, назван, адресован или обработан в сети.

<!-- v -->

REST представляет данные в виде ресурсов и использует стандартные методы HTTP для представления операций над этими ресурсами

<!-- v -->

#### Примеры ресурсов

[Stripe API](https://stripe.com/docs/api) представляет пользователей (customers), расходы (charges), платежный баланс (balance), возмещение денежных средств (refunds), события (events), файлы (files) и выплаты (payouts) как ресурсы.

<!-- v -->

#### Некоторые общие правила, которым следуют REST API:

<!-- v -->

Ресурсы являются частью URL-адресов, например **/users**

<!-- v -->

Для каждого ресурса обычно реализуются два URL-адреса: один для коллекции, например **/users**, и один для определенного элемента, например **/users/U123**

<!-- v -->

Существительные вместо глаголов. Например, вместо **/getUserInfo/U123** используется **/users/U123**

<!-- v -->

- **C**reate - используйте POST для создания новых ресурсов
- **R**ead - используйте GET для чтения ресурсов. Запросы GET никогда не изменяют состояние ресурса. У них нет побочных эффектов; метод GET имеет семантику только для чтения. GET идемпотентен. Следовательно, вы можете кэшировать вызовы.
- **U**pdate - используйте PUT для замены ресурса и PATCH для частичного обновления существующих ресурсов.
- **D**elete - используйте DELETE для удаления существующих ресурсов.
  <!-- v -->
  Стандартные коды состояния ответа HTTP возвращаются сервером, указывая на успех или неудачу.
- **2XX** успех
- **3XX** перемещение ресурса
- **4XX** ошибки на стороне клиента (например, отсутствие обязательного параметра или слишком много запросов)
- **5XX** ошибки на стороне сервера
  <!-- v -->
  CRUD операции, HTTP глаголы и REST соглашения

<img src="./images/REST_CRUD_operations.png" alt="CRUD операции, HTTP глаголы, and REST соглашения">
  <!-- v -->
  HTTP-запрос для получение платежа через Stripe API

```
GET /v1/charges/ch_CWyutlXs9pZyfD
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

HTTP-запрос для создание списания средств через Stripe API

```
POST /v1/charges
HOST api.stripe.com
Authorization: Bearer YNoJ1Yq64iCBhzfL9HNO00fzVrsEjtVl
```

<!-- v -->

Ресурс, который может существовать только в другом ресурсе, должен быть представлен как сабресурс, а не как ресурс верхнего уровня в URL-адресе.

<!-- v -->

Например, GitHub API использует сабресурсы для представления отношений в различных API:

<div style="text-align: left"> Создать issue</div>

```
POST /repos/:owner/:repo/issues
```

<div style="text-align: left"> Получить определенный issue</div>

```
GET /repos/:owner/:repo/issues/:number
```

<div style="text-align: left"> Получить все issue</div>

```
GET /repos/:owner/:repo/issues
```

<div style="text-align: left"> Изменить issue</div>

```
PATCH /repos/:owner/:repo/issues/:number
```

<!-- v -->

А что если нужно больше 4 видов операций? Например, архивировать репозиторий
<img src="./images/Archive_repo.png" alt="Архивировать репозиторий">

<!-- v -->

Помимо типичных операций CRUD, которые мы только что рассмотрели, API REST иногда может потребовать представления операций, не относящихся к CRUD. В этом случае обычно используются следующие подходы:

<!-- v -->

#### Действие как часть поля ресурса

API GitHub использует флаг **archive** в качестве входного параметра для API редактирования репозитория, чтобы представить действие архивирования репозитория

```console
PATCH /repos/vvscode/otus--javascript-basic
HOST api.github.com
Content-Type: application/json
Authorization: token OAUTH-TOKEN
{
  "archived": true
}
```

<!-- v -->

#### Действию как саб - ресурс

API GitHub использует этот шаблон для блокировки и разблокировки проблемы.

```console
PUT /repos/:owner/:repo/issues/:number/lock
```

<!-- v -->

Некоторые операции, такие как поиск, еще сложнее вписать в парадигму REST. Типичная практика в этом случае - использовать только команду действия в URL-адресе API.

```console
GET /search/code?q=:query:
```

Пример поиска файлов в GitHub, соответствующих заданному запросу.

<!-- s -->

### Remote Procedure Call

<!-- v -->

**Удаленный вызов процедур (RPC)** - это одна из простейших парадигм API, в которой клиент выполняет блок кода на другом сервере.

<!-- v -->

В то время как **REST** рассматривает ресурсы, RPC касается действий. Клиенты обычно передают имя метода и аргументы серверу и получают обратно JSON или XML.

<!-- v -->

API RPC обычно следуют двум простым правилам:

- endpoint-ы содержат имя выполняемой операции
- вызовы API выполняются с помощью наиболее подходящего HTTP-глагола: GET для запросов чтения и POST для других
  <!-- v -->
  Стиль RPC отлично подходит для API, которые предоставляют различные действия, которые могут иметь больше нюансов и сложностей, чем может быть инкапсулировано с помощью CRUD
  <!-- v -->
  Пример HTTP запроса к Slack API

```console
POST /api/conversations.archive
HOST slack.com
Content-Type: application/x-www-form-urlencoded
Authorization: Bearer xoxp-1650112-jgc2asDae
```

API позволяет выполнять несколько действий, таких как архивирование, присоединение, удаление, выход и переименование. Хотя в этом случае есть явный «ресурс», не все эти действия хорошо вписываются в шаблон REST.

<!-- v -->
<img src="./images/slack_conversation_API.png" alt="Slack conversation API">
<!-- s -->

### GraphQL

<!-- v -->

GraphQL - это язык запросов для API, который в последнее время приобрел значительную популярность.

Он был разработан внутри Facebook в 2012 году до публичного выпуска в 2015 году и был принят поставщиками API, такими как GitHub, Yelp и Pinterest.

<!-- v -->

GraphQL позволяет клиентам определять структуру требуемых данных, и сервер возвращает именно эту структуру.

GraphQL query

```console
{
    user(login: "saurabhsahni") {
      id
      name
      company
      createdAt
    }
}
```

Response from GitHub GraphQL API

```console
{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjY1MDI5",
      "name": "Saurabh Sahni",
      "company": "Slack",
      "createdAt": "2009-03-19T21:00:06Z"
    }
  }
}
```

<!-- v -->

В отличие от REST и RPC API, GraphQL API требует только одну конечную точку URL. Точно так же вам не нужны разные HTTP-команды для описания операции. Вместо этого вы указываете в теле JSON, выполняете ли вы запрос или мутацию.

<!-- v -->

#### GraphQL имеет несколько ключевых преимуществ перед REST и RPC:

<!-- v -->

GraphQL позволяет вкладывать запросы друг в друга и запрашивать данные с разных источников за один запрос. Без GraphQL может понадобиться множество HTTP вызовов на сервер.

<!-- v -->

__Нет управления версиями__  
Вы можете добавлять новые поля и типы в GraphQL API, не затрагивая существующие запросы. Точно так же проще отказаться от использования существующих полей.

<!-- v -->

__Ничего лишнего__  
Благодаря GraphQL, поскольку клиенты могут точно указать, что им нужно, размеры полезной нагрузки могут быть меньше.

<!-- v -->

__Строго типизированный__  
GraphQL строго типизирован. Во время разработки проверка типов GraphQL помогает гарантировать, что запрос синтаксически верен и действителен.

<!-- v -->

__Самодокументированность__  
Хотя существуют внешние решения, такие как Swagger, которые помогают упростить изучение REST API, в GraphQL изначально поставляется с GraphQL, встроенной в браузер IDE для изучения GraphQL.

<!-- v -->

#### Что, одни плюсы?!

<!-- v -->

#### Минусы:

- Хотя GraphQL имеет множество преимуществ, одним из его недостатков является сложность, которую он добавляет поставщику API.
- Серверу требуется дополнительная обработка для анализа сложных запросов и проверки параметров.
- Оптимизация производительности запросов GraphQL тоже может быть сложной задачей.

<!-- v -->

Для внутренних нужд компании легко предсказать варианты использования и отладить узкие места в производительности. При работе с внешними разработчиками эти варианты использования становятся трудными для понимания и оптимизации.

<!-- v -->

#### Резюмируем

<img src="./images/comparision2.png" alt="Сводная таблица различий 3 подходов">

<!-- s -->

### XMLHttpRequest vs fetch

<!-- v -->

Следующий код JavaScript показывает базовый HTTP-запрос GET для http://www.7timer.info с использованием XMLHttpRequest (обычно сокращается до XHR):

```javascript
const xhr = new XMLHttpRequest();
xhr.open(
  "GET",
  "https://www.7timer.info/bin/astro.php?lon=113.2&lat=23.1&output=json"
);
// Подписываемся на изменение состояния запроса
xhr.onreadystatechange = function () {
  // Проверка, завершилось ли выполнение запроса?
  if (xhr.readyState !== 4) return;

  if (xhr.status === 200) {
    // Обработка удачного выполнения запроса
    console.log(xhr.responseText);
  } else {
    // Обработка ошибки
    console.log("HTTP error", xhr.status, xhr.statusText);
  }
};
// Отправляем запрос
xhr.send();
```

<!-- v -->

Объект XMLHttpRequest имеет много других параметров, событий и свойств ответа. Например, тайм-аут в миллисекундах может быть установлен и обнаружен:

```javascript
// установка timeout
xhr.timeout = 3000; // 3 секунды
xhr.ontimeout = () => console.log("timeout", xhr.responseURL);
```

<!-- v -->

и событие progress может сообщить о длительной загрузке файла:

```javascript
xhr.upload.onprogress = (p) => {
  console.log(Math.round((p.loaded / p.total) * 100) + "%");
};
```

<!-- v -->

Также запрос XHR легко завершить с помощью `xhr.abort()` и, при необходимости, обнаружить такое событие с помощью функции `xhr.onabort`.

<!-- v -->

Число параметров может вызывать недоумение, и ранние реализации XMLHttpRequest имели несколько кросс-браузерных несоответствий. По этой причине большинство библиотек и сред предлагают функции-оболочки Ajax для решения этих проблем, например, метод jQuery.ajax():

```javascript
$.ajax("http://domain/service")
  .done((data) => console.log(data))
  .fail((xhr, status) => console.log("error:", status));
```

<!-- v -->

**Fetch** API является современной альтернативой XMLHttpRequest. Универсальные интерфейсы Headers, Request и Response обеспечивают согласованность, в то время как Promises позволяют упростить цепочки и async/await без обратных вызовов.

<!-- v -->

Приведенный выше пример XHR можно преобразовать в гораздо более простой код на основе Fetch, который даже анализирует возвращенный JSON:

```javascript
fetch("http://domain/service", { method: "GET" })
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.error("error:", error));
```

<!-- v -->

Fetch - чистый, элегантный и простой для понимания. Почему бы нам не использовать его вместо древнего XMLHttpRequest?

<!-- v -->

Fetch API достаточно хорошо поддерживается, но он не будет работать во всех выпусках Internet Explorer. Люди, использующие версии Chrome, Firefox и Safari старше 2017 года, также могут испытывать проблемы.

<!-- v -->

Удивительно, но ошибка HTTP, такая как **404 Page Not Found** или **500 Internal Server Error**, не попадет в `.catch()`. Обычно он разрешается с состоянием response.ok, установленным в false.

<!-- v -->

#### Отмена запроса

Прекращение отправки было невозможно в течение нескольких лет, но теперь оно поддерживается в браузерах, которые реализуют API `AbortController`. Это запускает сигнал, который может быть передан объекту инициации Fetch:

```javascript
const controller = new AbortController();
fetch("http://domain/service", {
  method: "GET",
  signal: controller.signal,
})
  .then((response) => response.json())
  .then((json) => console.log(json))
  .catch((error) => console.error("Error:", error));
```

Обработка может быть прервана вызовом controller.abort(). Будет вызвана функция `.catch()`.

<!-- v -->

#### Нет прогресса

На момент написания, Fetch не поддерживает события прогресса. Поэтому невозможно сообщить о статусе загрузки файлов или аналогичных представлений больших форм.

<!-- s -->

### Рассмотрим REST поближе

<!-- v -->

**что значит RESTful**

- Client-Server
- Stateless
- Cache
- Uniform Interface
- Layered System
- Code-On-Demand (опционально)
<!-- v -->

#### Client-Server

- **клиенты** не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается
- **серверы** не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы
<!-- v -->

#### Stateless

Сервер не должен хранить какой-либо информации о клиентах и последних запросах. Каждый запрос - как новый. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента. No session, no history.

<!-- v -->

#### Cache

Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.

<!-- v -->

#### Uniform Interface

- Identification of resources
- Manipulation of resources through representations
- Self-descriptive messages
- HATEOAS
<!-- v -->

#### Layered System

Многоуровневость достигается за счёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.

<!-- v -->

#### Code-On-Demand (опционально)

REST позволяет наращивать функциональность клиентского приложения по мере необходимости при помощи скачивания и исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, уменьшая количество заранее написанных возможностей.

<!-- s -->

### OAuth

<!-- v -->
<img src="./images/oauth_example1.png" alt="Пример OAuth">
<!-- v -->
<img src="./images/oauth_example2.png" alt="Пример OAuth">
<!-- v -->
**OAuth 2.0** — протокол авторизации, позволяющий выдать одному сервису (приложению) права на доступ к ресурсам пользователя на другом сервисе.

- нет необходимости доверять логин и пароль
- выдаем ограниченный набор прав

<!-- v -->

Сначала определимся с терминами, что такое аутентификация/авторизация? Есть ли разница?

<!-- v -->

**Authentication** - процесс проверки того, кто вы есть. Веб-приложения обычно добиваются этого, предлагая вам войти в систему с именем пользователя и паролем.

<!-- v -->

**Authorization** - процесс подтверждения того, что вам разрешено делать то, что вы пытаетесь сделать.

<!-- v -->

При разработке API необходимо подумать о том, как разработчики приложений будут выполнять как аутентификацию, так и авторизацию с помощью вашего API.

<!-- v -->

Вначале поставщики API начали поддерживать **Basic Authentication**. Это простейший метод, используемый для обеспечения контроля доступа в Интернете.

<!-- v -->

Клиенты отправляют HTTP-запросы с заголовком **Authorization**, в качестве значения используется строка: `Basic user:password`. **`user:password`** кодируется с помощью base64

```console
Authorization: Basic dXNlcjpwYXNzd29yZA==
```

<!-- v -->

Если вы используете **Basic Authentication** для своего API, чтобы использовать приложение стороннего разработчика, вашим пользователям может потребоваться предоставить им свои учетные данные для имени пользователя и пароля. Почему это плохо?

<!-- v -->

Приложения должны хранить эти учетные данные в виде открытого текста или таким образом, чтобы они могли их расшифровать.

<!-- v -->

Пользователи не могут отозвать доступ к одному приложению, не отозвав доступ ко всем приложениям, изменив пароль.

<!-- v -->

Приложения получают полный доступ к учетным записям пользователей. Пользователи не могут ограничивать доступ к выбранным ресурсам.

<!-- v -->

По этим причинам Twitter решил прекратить поддержку **Basic Authentication** для своего основного API в 2010 году.

<!-- v -->

Самым большим преимуществом OAuth является то, что пользователям не нужно сообщать приложениям пароли. Рассмотрим пример.

<!-- v -->

Предположим, что TripAdvisor хочет создать приложение, которое будет использовать идентификационные данные пользователя Facebook, профиль, список друзей и другие данные Facebook.

<!-- v -->

С помощью OAuth TripAdvisor может перенаправить этого пользователя на Facebook, где он может разрешить TripAdvisor доступ к своей информации:

<img src="./images/ta1.png" alt="Пример TripAdvisor" width="600px">

После того, как пользователь разрешит совместное использование данных, TripAdvisor может вызвать API Facebook для получения этой информации.

<!-- s -->

### Плюсы OAUTH

<!-- v -->

Пользователям не нужно сообщать приложениям пароли.

<!-- v -->

Второе преимущество OAuth заключается в том, что он позволяет пользователям поставщиков API предоставлять выборочные разрешения.

<!-- v -->

В прошлом примере TripAdvisor получит разрешение на чтение профиля пользователя, списка друзей и т.д., Но не может публиковать сообщения от имени пользователя в Facebook.

<!-- v -->

Наконец, если в какой-то момент пользователь захочет отозвать доступ TripAdvisor к своим данным в Facebook, он может просто зайти в свои настройки Facebook и отозвать его, не меняя пароль.

<!-- s -->

### Флоу OAuth

<!-- v -->

С OAuth приложения используют токен доступа для вызова API от имени пользователя.

<!-- v -->

Получение токена происходит в три этапа:

<!-- v -->

Приложение направляет пользователя к провайдеру API для авторизации.
В приложениях обычно сначала отображается кнопка с надписью «Продолжить с Facebook».  
<img src="./images/oauth_example2.png" alt="Пример OAuth" width="400px">  
Когда пользователи нажимают кнопку, они перенаправляются на URL-адрес авторизации поставщика API.  
При перенаправлении приложение отправляет **clientId** и запрошенные разрешения(**scope**)

<!-- v -->

Поставщик API запрашивает авторизацию пользователя.  
Поставщик API должен четко указывать, какие разрешения запрашивает приложение.  
<img src="./images/requestScope.png" alt="Запрос на разрешение" width="400px">  
Если пользователь одобряет запрос, он перенаправляется обратно в приложение с кодом авторизации.

<!-- v -->

Приложение обменивает код авторизации на токен доступа **accessToken**.
<img src="./images/oauth_flow.png" alt="Запрос на разрешение" width="600px">

<!-- v -->

После того, как разработчики получили токен доступа, они могут начать делать запросы API, используя этот доступ, установив заголовок авторизации HTTP.

```console
POST /api/chat.postMessage
HOST slack.com
Content-Type: application/json
Authorization: Bearer xoxp-16501860-a24afg234
{
  ...
 }
```

<!-- v -->

При получении этих запросов серверам поставщиков API необходимо проверить две вещи.

<!-- v -->

- Во-первых, токен доступа действителен. Вам необходимо сопоставить данный токен доступа с предоставленными токенами доступа в вашей базе данных.
  <!-- v -->
  Во-вторых, токен доступа имеет необходимую область действия, которое должен выполнить запрос. Если какая-либо из проверок не удалась, сервер должен вернуть ошибку.

<!-- s -->

Дополнительные материалы:

- [REST простым языком](https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78)
- [Получение данных с сервера](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data)
- [OAuth простым и понятным языком](https://habr.com/ru/company/mailru/blog/115163/)
<!-- s -->

### Опрос о занятии
