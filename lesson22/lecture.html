<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 22</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />


    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

Преподаватель

</script></section><section data-markdown><script type="text/template">

### План вебинара:

- Чистые функции
- Immutable data
- Функции как first class citizens
- Функции высшего порядка
- Декларативный VS императивный подходы
- Семантика методов массива
- Композиция и каррирование

</script></section></section><section ><section data-markdown><script type="text/template">

## Функциональное программирование

</script></section><section data-markdown><script type="text/template">

**Функциональное программирование (ФП)** — предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемости этого состояния.

</script></section><section data-markdown><script type="text/template">

- Есть функции и данные
- Данные иммутабельны, неизменны
- Функции возвращают новые данные на основе входящих значений

</script></section></section><section ><section data-markdown><script type="text/template">

## Чистые функции

</script></section><section data-markdown><script type="text/template">

**Чистые функции** - выходные данные зависят только от входных. Функции "без побочных эффектов".

</script></section><section data-markdown><script type="text/template">

Является ли функция чистой?

```js [1-30]
const set = new Set();

function hasDuplicates(arr) {
  return arr.some((val) => {
    if (set.has(val)) return true;
    else {
      set.add(val);
      return false;
    }
  });
}
```

</script></section><section data-markdown><script type="text/template">

Пример чистой функции

```js [1-30]
function hasDuplicates(arr) {
  const set = new Set();
  return arr.some((val) => {
    if (set.has(val)) return true;
    else {
      set.add(val);
      return false;
    }
  });
}
```

Более короткий вариант

```js [1-30]
new Set(arr).values().length === arr.length;
```

</script></section><section data-markdown><script type="text/template">

- если результат чистой функции не используется, её вызов может быть удалён

- результат вызова чистой функции может быть мемоизирован

- если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их вычисления можно поменять

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Immutable data

</script></section><section data-markdown><script type="text/template">

**Что же такое мутация?**

</script></section><section data-markdown><script type="text/template">

**Мутация** — это изменение существующих данных или структуры, которая их в себе хранит.

```js [1-30]
const person = {
  name: "John",
  age: 28,
};
const newPerson = person;
newPerson.age = 30;
console.log(newPerson === person); // истина
console.log(person); // { name: 'John', age: 30 }
```

</script></section><section data-markdown><script type="text/template">

**Иммутабельность** предполагает создание копии существующих данных или структуры, когда необходимы изменения, и добавление этих изменений туда.

</script></section><section data-markdown><script type="text/template">

#### Способы создания копии объекта #1

Object.assign(target, ...sources)

```js [1-30]
const person = {
  name: "John",
  age: 28,
};
const newPerson = Object.assign({}, person, {
  age: 30,
});
console.log(newPerson === person); // ложь
console.log(person); // { name: 'John', age: 28 }
console.log(newPerson); // { name: 'John', age: 30 }
```

После копирования возвращается целевой объект(target).

</script></section><section data-markdown><script type="text/template">

#### Способы создания копии объекта #2

Оператор spread

```js [1-30]
const person = {
  name: "John",
  age: 28,
};
const newPerson = {
  ...person,
  age: 30,
};
console.log(newPerson === person); // ложь
console.log(newPerson); // { name: 'John', age: 30 }
```

</script></section><section data-markdown><script type="text/template">

#### Способы создания копии объекта #3

Для глубокой копии можно использовать

```js [1-30]
target = JSON.parse(JSON.stringify(source));
```

ВАЖНО! JSON.stringify упадет, если будут циклические зависимости, а также не будет копировать методы.

</script></section><section data-markdown><script type="text/template">

А если нужно убрать элемент?

```js [1-30]
const person = {
  name: "John",
  password: "123",
  age: 28,
};
const newPerson = Object.keys(person).reduce((obj, key) => {
  if (key !== property) {
    return { ...obj, [key]: person[key] };
  }
  return obj;
}, {});
```

Еще вариант:

```js [1-30]
const { redundantProperty, ...newPerson } = person;
```

</script></section><section data-markdown><script type="text/template">

#### Заморозка объекта

```js [1-30]
Object.freeze(target);
```

Заморозка объекта будет поверхностной(shallow)  
Для глубокой заморозки объекта ребята из [Mozilla](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) написали готовый способ

</script></section><section data-markdown><script type="text/template">

Плюсы:

- блокировка для многопоточности больше не является проблемой: если данные не изменяются, нет необходимости в какой-либо блокировке, чтобы синхронизировать разные потоки;
- отслеживать изменения в данных намного проще(достаточно сравнить ссылки на объект)

Минусы:

- использование иммутабельных структур данных по своей природе является причиной пиковых значений в использовании памяти.
</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## First class functions

</script></section><section data-markdown><script type="text/template">

Функция - полноценный гражданин программы

- можно передать в качестве аргумента другой функции

- можно вернуть функцию из другой функции

- можно присвоить переменной или сохранить в структуре данных

</script></section><section data-markdown><script type="text/template">

Передача функции в качестве аргумента другой функции

```js [1-30]
function callArgument(cb) {
  cb();
}

function sayHello() {
  console.log("Hello!");
}

callArgument(sayHello);
```

</script></section><section data-markdown><script type="text/template">

Возврат функции как результат другой функции

```js [1-30]
function getHello() {
  return function () {
    console.log("Hello!");
  };
}

const sayHello = getHello();
sayHello();
```

</script></section><section data-markdown><script type="text/template">

Сохранение в структурах данных

```js [1-30]
function sayHello() {
  console.log("Hello!");
}
function sayDratuti() {
  console.log("Dratuti!");
}
function sayBonjour() {
  console.log("Bonjour!");
}

const sayArray = [];
sayArray.push(sayHello);
sayArray.push(sayDratuti);
sayArray.push(sayBonjour);
sayArray.forEach((say) => say());
```

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Функции высшего порядка

</script></section><section data-markdown><script type="text/template">

**Функция высшего порядка** — в программировании функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

</script></section><section data-markdown><script type="text/template">

**Мемоизация** — в программировании сохранение результатов выполнения функций для предотвращения повторных вычислений.

</script></section><section data-markdown><script type="text/template">

Реализуем? :)
[Memo](https://codesandbox.io/s/github/acsais/otus--javascript-basic/tree/lesson22/lessons/lesson22/code/memo)

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Декларативный VS императивный подходы

</script></section><section data-markdown><script type="text/template">

Императивный подход отвечает на вопрос КАК?

Декларативный подход отвечает на вопрос ЧТО?

</script></section><section data-markdown><script type="text/template">

Напишите функцию double, которая принимает массив чисел и возвращает новый массив после удвоения каждого элемента в этом массиве. double([1,2,3]) -> [2,4,6]

Напишите функцию add, которая принимает массив и возвращает результат сложения элементов массива. add ([1,2,3]) -> 6

</script></section><section data-markdown><script type="text/template">

Императивный стиль

```js [1-30]
function double(arr) {
  let results = [];
  for (let i = 0; i < arr.length; i++) {
    results.push(arr[i] * 2);
  }
  return results;
}
// ---
function add(arr) {
  let result = 0;
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```

</script></section><section data-markdown><script type="text/template">

Декларативный стиль

```js [1-30]
function double(arr) {
  return arr.map((item) => item * 2);
}
// ---
function add(arr) {
  return arr.reduce((prev, current) => prev + current, 0);
}
```

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Семантика методов массива

</script></section><section data-markdown><script type="text/template">

#### Метод forEach

<!-- eslint-skip -->

```js [1-30]
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
}[, thisArg]);
```

Возвращает undefined  
Не стоит использовать для изменения значений

</script></section><section data-markdown><script type="text/template">

#### Метод sort

```js [1-30]
arr.sort([compareFunction]);
```

Сортирует массив "на месте", т.е. изменяет исходный массив.  
Не ~~по фэншую~~ в стиле ФП :)

</script></section><section data-markdown><script type="text/template">

#### Метод filter

<!-- eslint-skip -->

```js [1-30]
let newArray = arr.filter(callback(element[, index, [array]])[, thisArg])
```

Вернётся новый массив с элементами, которые проходят тест(то есть callback вернёт true).

</script></section><section data-markdown><script type="text/template">

#### Метод reduce

<!-- eslint-skip -->

```js [1-30]
array.reduce(callback[, initialValue])
```

```js [1-30]
callback(accumulator, currentValue);
```

Пример:

```js [1-30]
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;
console.log(array1.reduce(reducer, 5)); // 15
```

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Композиция и каррирование

</script></section><section data-markdown><script type="text/template">

**Композиция** - создание сложной функциональности за счет объединения более простых функций.

</script></section><section data-markdown><script type="text/template">

#### Пример

`upperCase` - возьмет строку и вернет её в верхнем регистре

`exclaim` - возьмет строку и добавит восклицательный знак

`repeat` - возьмет строку и утроит её, добавив пробел между ними

```js [1-30]
const upperCase = (str) => str.toUpperCase();
const exclaim = (str) => `${str}!`;
const repeat = (str) => `${str} `.repeat(3);
```

</script></section><section data-markdown><script type="text/template">

Исходная строка «I love coding»

```js [1-30]
const upperCase = (str) => str.toUpperCase();
const exclaim = (str) => `${str}!`;
const repeat = (str) => `${str} `.repeat(3);

console.log(
  repeat(exclaim(upperCase("I love coding"))) // I LOVE CODING! I LOVE CODING! I LOVE CODING!
);
```

Проблема - вызов получился длинным и трудным для чтения

</script></section><section data-markdown><script type="text/template">

Создадим функцию `compose`, которая должна работать следующим образом:

```js [1-30]
const withСompose = compose(upperCase, exclaim, repeat);

console.log(withСompose("I love coding")); // I LOVE CODING! I LOVE CODING! I LOVE CODING!
```

[Compose](https://codesandbox.io/s/github/acsais/otus--javascript-basic/tree/lesson22/lessons/lesson22/code/compose)

</script></section><section data-markdown><script type="text/template">

**Каррирование** – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).

</script></section><section data-markdown><script type="text/template">

Пример:

```js [1-30]
function curry(f) {
  // curry(f) выполняет каррирование
  return function (a) {
    return function (b) {
      return f(a, b);
    };
  };
}

// использование
function sum(a, b) {
  return a + b;
}

let carriedSum = curry(sum);

alert(carriedSum(1)(2)); // 3
```

</script></section></section><section ><section data-markdown><script type="text/template">
</script></section><section data-markdown><script type="text/template">

Дополнительные материалы:
[Методы и свойства массивов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)
[Методы и свойства объектов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)

</script></section><section data-markdown><script type="text/template">

### Опрос о занятии
</script></section></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%","tableofcontents":{"title":"План","position":1000}}, queryOptions);
    </script>

    <script src="./../_assets/plugins.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
