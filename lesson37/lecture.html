<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 38</title>
    <link rel="shortcut icon" href="./../favicon.ico"/>
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />

    <script>
      document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

## Разработка виджетов, микроприложений

</script></section><section data-markdown><script type="text/template">

Причины возникновения микроприложений на клиенте:

- большой размер приложений, с широким функционалом
- желание предоставлять обновления максимально часто (и без влияния на другие части приложения)
- большая команда, что увеличивает частоту релизов

</script></section><section data-markdown><script type="text/template">

Какие инструменты у нас для этого есть?

- разбиение на модули
- снижение связанности

</script></section><section data-markdown><script type="text/template">

Но! В обычном приложении мы все еще создаем модули на одной технологии, в одном репозитории и они работают в неизолированном окружении. Это влияет как на CSS так и на JS (глобальные объекты).

</script></section><section data-markdown><script type="text/template">

Для решения проблем модульности в стилях мы можем использовать:

- [BEM](https://avivi.pro/blog/metodologiya-bem-v-deystvii/) / [CSS модули](https://frontender.info/css-modules-part-1-need/)
- [iframe](https://habr.com/ru/post/488516/)
- [Shadow DOM](https://learn.javascript.ru/shadow-dom)

</script></section><section data-markdown><script type="text/template">

Для решения проблем модульности в JS мы можем использовать:

- [iframe](https://habr.com/ru/post/488516/)
- не использовать глобальные переменные (фактически не возможно)

</script></section><section data-markdown><script type="text/template">

Но это не решает вопрос привязки к технологиям разработки:

- для разных задач хороши разные инструменты
- для разных команд хороши разные инструменты

</script></section><section data-markdown><script type="text/template">

Решением может являться независимая разработка частей. Когда каждый модуль/виджет представлен отдельным (одним или несколькими) js-файлом.

Причем подключать их не обязательно сразу. Не редко используется прием [динамической загрузки скриптов](https://learn.javascript.ru/external-script)

</script></section><section data-markdown><script type="text/template">

```js
function addScript(src) {
  var script = document.createElement("script");
  script.src = src;
  script.async = false; // чтобы гарантировать порядок
  document.head.appendChild(script);
}
// ...
addScript("weaterForm.js");
addScript("weaterHistoryList.js");
```

</script></section><section data-markdown><script type="text/template">

Решением, которое позволяло делать это и гарантировало подключение модулей в качестве зависимостей долгое время была библиотека [require.js](https://requirejs.org/)

```js [1-30]
// my/shirt.js
// https://requirejs.org/docs/api.html#defdep
define(["./cart", "./inventory"], function (cart, inventory) {
  //return an object to define the "my/shirt" module.
  return {
    color: "blue",
    size: "large",
    addToCart: function () {
      inventory.decrement(this);
      cart.add(this);
    },
  };
});
// ...
require("my/shirt.js").addToCart();
```

</script></section><section data-markdown><script type="text/template">

При этом, если скрипты мы загружаем разными файлами, у нас нет больше ограничение на технологии. Каждый файл (или группа файлов) может использовать свои инструменты (React/Vue/чистый javascript).

Нам только нужно соблюдать интерфейс модулей. Или, для упрощения, сделать так, чтобы подключаемые файлы не предоставляли никакого интерфейса вообще (решается вопрос сопряжения модулей).

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section><section data-markdown><script type="text/template">

Как организовать общение таких независимо загруженных частей?

</script></section><section data-markdown><script type="text/template">

[EventTarget](https://developer.mozilla.org/ru/docs/Web/API/EventTarget)/[postMessage API](https://developer.mozilla.org/ru/docs/Web/API/Window/postMessage)/собственная шина событий

Например [вот так](https://codesandbox.io/s/widget-communication-nsvbw)

</script></section><section data-markdown><script type="text/template">

Как могут активироваться такие части:

- в зависимости от URL (когда за отдельные страницы отвечает свой модуль)
- в зависимости от блоки (когда за отдельные части на странице отвечает свой модуль)
- смешанный подход

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section  data-markdown><script type="text/template">

### Дополнительные материалы

- [YT: Харин Дмитрий - Микрофронтенд – велосипед или космический корабль?](https://www.youtube.com/watch?v=32OcecQV6lo)
- [YT: Микрофронтенды как решение проблем кратного роста команды](https://www.youtube.com/watch?v=5ekkGugwAEg)
- [YT: Микросервисный фронтенд](https://www.youtube.com/watch?v=YANolrn4PYc)
- [YT: Фронтенд-приложения как микросервисы](https://www.youtube.com/watch?v=pcb2rOX_9Dg)
- [Микрофронтенды. Учимся на ошибках](https://habr.com/ru/post/515418/)
- [YT: Микросервисный фронтенд. Как подружить vue.js и react](https://www.youtube.com/watch?v=XD02n4GXjU8)
</script></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":true,"backgroundTransition":"fade","width":"80%"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
