<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 37</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />


    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

## Разработка виджетов, микроприложений

</script></section><section data-markdown><script type="text/template">

Причины возникновения микроприложений на клиенте:

- большой размер приложений, с широким функционалом
- желание предоставлять обновления максимально часто (и без влияния на другие части приложения)
- большая команда, что увеличивает частоту релизов

</script></section><section data-markdown><script type="text/template">

Какие инструменты у нас для этого есть?

- разбиение на модули
- снижение связанности

</script></section><section data-markdown><script type="text/template">

Но! В обычном приложении мы все еще создаем модули на одной технологии, в одном репозитории и они работают в неизолированном окружении. Это влияет как на CSS так и на JS (глобальные объекты)

</script></section><section data-markdown><script type="text/template">

В итоге мы можем получить проблемы:

- протекание среды выполнения javascript (глобальные объекты, прототипы)
- протекание событий (при использовании делегирования на `document.body`)
- протекание стилей (влияние каскада, пересечение стилевых правил)

</script></section><section data-markdown><script type="text/template">

Решения с проблемой глобальных объектов почти нет:

- отказ от их использования в принципе. Это не сложно сделать в своем коде (мы используем современный стек с модульностью, для подключения пакетов), но мы не можем иметь таких гарантий относительно [стороннего кода](https://www.audero.it/blog/2016/12/05/monkey-patching-javascript/)

- использование отдельных контекстов исполнения за счет использования `iframe`

</script></section><section data-markdown><script type="text/template">

Для решения проблемы протекания событий можно использовать:

- делегирование на блок-обертку (вместо корневого `document.body`)
- использование [iframe](https://developer.mozilla.org/ru/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies)
- использование [Shadow DOM](https://learn.javascript.ru/shadow-dom)

Просто к слову - одно из обновления [в React 17 как раз изменение в делегировании](https://ru.reactjs.org/blog/2020/10/20/react-v17.html#changes-to-event-delegation).

</script></section><section data-markdown><script type="text/template">

Для решения проблем модульности в стилях мы можем использовать:

- [BEM](https://avivi.pro/blog/metodologiya-bem-v-deystvii/) / [CSS модули](https://frontender.info/css-modules-part-1-need/) - обеспечить уникальность селекторов за счет префиксов или родительского селектора в стилях
- [iframe](https://habr.com/ru/post/488516/) / [Shadow DOM](https://learn.javascript.ru/shadow-dom) - как отдельные DOM сущности для вложенных элементах

</script></section><section data-markdown><script type="text/template">

Вопросы?

</script></section><section data-markdown><script type="text/template">

Но это не решает вопрос привязки к технологиям разработки:

- для разных задач хороши разные инструменты
- для разных команд хороши разные инструменты

</script></section><section data-markdown><script type="text/template">

Решением может являться независимая разработка частей. Когда каждый модуль/виджет представлен отдельным (одним или несколькими) js-файлом.

Причем подключать их не обязательно сразу. Не редко используется прием [динамической загрузки скриптов](https://learn.javascript.ru/external-script)

</script></section><section data-markdown><script type="text/template">

```js
function addScript(src) {
  var script = document.createElement("script");
  script.src = src;
  script.async = false; // чтобы гарантировать порядок
  document.head.appendChild(script);
}
// ...
addScript("weaterForm.js");
addScript("weaterHistoryList.js");
```

</script></section><section data-markdown><script type="text/template">

Решением, которое позволяло делать это и гарантировало подключение модулей в качестве зависимостей долгое время была библиотека [require.js](https://requirejs.org/)

```js [1-30]
// my/shirt.js
// https://requirejs.org/docs/api.html#defdep
define(["./cart", "./inventory"], function (cart, inventory) {
  //return an object to define the "my/shirt" module.
  return {
    color: "blue",
    size: "large",
    addToCart: function () {
      inventory.decrement(this);
      cart.add(this);
    },
  };
});
// ...
require("my/shirt.js").addToCart();
```

</script></section><section data-markdown><script type="text/template">

При этом, если скрипты мы загружаем разными файлами, у нас нет больше ограничение на технологии. Каждый файл (или группа файлов) может использовать свои инструменты (React/Vue/чистый javascript).

Нам только нужно соблюдать интерфейс модулей. Или, для упрощения, сделать так, чтобы подключаемые файлы не предоставляли никакого интерфейса вообще (решается вопрос сопряжения модулей).

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section><section data-markdown><script type="text/template">

Как организовать общение таких независимо загруженных частей?

</script></section><section data-markdown><script type="text/template">

[EventTarget](https://developer.mozilla.org/ru/docs/Web/API/EventTarget)/[postMessage API](https://developer.mozilla.org/ru/docs/Web/API/Window/postMessage)/собственная шина событий

Например [вот так](https://codesandbox.io/s/widget-communication-nsvbw)

</script></section><section data-markdown><script type="text/template">

Как могут активироваться такие части:

- в зависимости от URL (когда за отдельные страницы отвечает свой модуль)
- в зависимости от блоки (когда за отдельные части на странице отвечает свой модуль)
- смешанный подход

</script></section><section data-markdown><script type="text/template">

Дополнительная проблема, которая может вставать при таком подходе - дублирование загружаемого кода (когда разные под-приложения на нашей странице используют одни и те-же библиотеки).

</script></section><section data-markdown><script type="text/template">

Решения:

- [динамическая загрузка кода](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82) (если нужна поддержка старых браузеров можно брать [require.js](https://requirejs.org/))
- [Module Federation](https://habr.com/ru/post/506634/) - для обмена модулями между Javascript приложениями

Но все еще нужно держать в голове вопрос, связанный с версиями пакетов

</script></section><section data-markdown><script type="text/template">

[Некоторые инструменты сборки позволяют использовать загрузку модулей с CDN](https://hqjs.org/) - это, в том числе, позволяет обновлять части приложения на лету

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section  data-markdown><script type="text/template">

### Дополнительные материалы

- [YT: Харин Дмитрий - Микрофронтенд – велосипед или космический корабль?](https://www.youtube.com/watch?v=32OcecQV6lo)
- [YT: Микрофронтенды как решение проблем кратного роста команды](https://www.youtube.com/watch?v=5ekkGugwAEg)
- [YT: Микросервисный фронтенд](https://www.youtube.com/watch?v=YANolrn4PYc)
- [YT: Фронтенд-приложения как микросервисы](https://www.youtube.com/watch?v=pcb2rOX_9Dg)
- [Микрофронтенды. Учимся на ошибках](https://habr.com/ru/post/515418/)
- [YT: Микросервисный фронтенд. Как подружить vue.js и react](https://www.youtube.com/watch?v=XD02n4GXjU8)
</script></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%","tableofcontents":{"title":"План","position":1000}}, queryOptions);
    </script>

    <script src="./../_assets/plugins.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
