<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 25</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />


    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

### План вебинара:

- Single responsibility
- Абстракция и инкапсуляция, сервисы
- разбиение на MVC
- использование компонентного подхода

</script></section></section><section ><section data-markdown><script type="text/template">

## Single responsibility

</script></section><section data-markdown><script type="text/template">

принципы **SOLID** были придуманы Робертом Мартином.

**SRP** - принцип единой ответственности.

Мартин определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только одну причину для изменений.

</script></section><section data-markdown><script type="text/template">

Рассмотрим пример

```js [1-30]
class Car {
  constructor(name, model, year) {
    this.name = name;
    this.model = model;
    this.year = year;
  }
  getCar(id) {
    return this.http.get("api/cars/" + id);
  }
  saveCar() {
    return this.post("api/cars", {
      name: this.name,
      year: this.year,
      model: this.model,
    });
  }
}
```

</script></section><section data-markdown><script type="text/template">

```js [1-30]
class Car {
  constructor(name, model, year) {
    this.name = name;
    this.model = model;
    this.year = year;
  }
}
class CarService {
  getCar(id) {
    return this.http.get("api/cars/" + id);
  }
  saveCar(car) {
    this.http.post("api/cars", car);
  }
}
```

</script></section><section data-markdown><script type="text/template">

Еще один пример:

```js [1-30]
class Product {
  get(name) {}
  set(name, value) {}
  save() {}
  update() {}
  delete() {}
  show() {}
  print() {}
}
```

</script></section><section data-markdown><script type="text/template">

```js [1-30]
class ProductEntity {
  get(name) {}
  set(name, value) {}
}
class ProductRepository {
  save() {}
  update() {}
  delete() {}
}
class ProductView {
  show() {}
  print() {}
}
```

</script></section><section data-markdown><script type="text/template">

Рассмотрим еще один пример, класс User:

```js [1-30]
// сохранение данных
user = new User();
user.firstname = "James";
user.lastname = "Bond";
user.save();

// получение данных из базы
user = new User();
user.getByFirstName("John");

// получение данных их связанной таблицы
role = user2.role;
```

При такой архитектуре все будет хорошо работать если проект будет небольшим. Но с ростом проекта увеличением количества требуемых методов, будет расти и сложность архитектуры, все очень быстро может стать запутанным.

</script></section><section data-markdown><script type="text/template">

Разделить на сущность пользователя класс `UserEntity` и класс для работы с базой данных `UserRepository`:

```js [1-30]
// сохранение данных
user = new UserEntity();
user.firstname = "James";
user.lastname = "Bond";
userRepository = new UserRepository();
userRepository.save(user);
// получение данных
userRepository = new UserRepository();
userRepository.getByFirstName("John");
// получение данных их связанной таблицы
role = userRepository.role;
```

</script></section><section data-markdown><script type="text/template">

Еще один пример. Пусть у нас есть класс, который отвечает как за генерацию отчета и за его отправку определенному пользователю

```js [1-30]
class FinancialReportMailer {
  constructor(transactions, account) {
    this.transactions = transactions;
    this.account = account;
    this.report = "";
  }
  generate_report() {
    // generate report
    this.report = make_report;
  }
  send_report() {}
  // send report this.report
}
mailer = FinancialReportMailer(transactions, account);
mailer.generate_report();
mailer.send_report();
```

</script></section><section data-markdown><script type="text/template">

Давайте посмотрим, как выглядит этот код после того, как мы реорганизовали его для соответствия требованиям SRP:

```js [1-30]
class FinancialReportMailer {
  deliver(report, account) {
    //send report
  }
}
class FinancialReportGenerator {
  generate() {
    // generate report
  }
}

report = FinancialReportGenerator().generate();
FinancialReportMailer.deliver(report, account);
```

Если бы мы хотели расширить класс, отвечающий за генерацию отчетов в будущем, мы могли бы просто внести необходимые изменения, не касаясь класса `FinancialReportMailer`.

</script></section><section data-markdown><script type="text/template">

Важно! Принцип применяется не только к классам, но и функциям:

```js [1-30]
function report() {
  //generate report logic
  //..
  //send report
}
```

```js [1-30]
function generateReport() {
  //generate report logic
}
function sendReport() {
  //send report
}
```

Принцип также масштабируется и в обратную сторону, то есть модуль(со множеством файлом) должен также иметь одну причину для изменения.

</script></section><section data-markdown><script type="text/template">

Этот принцип применяется, когда:

- Нужно сделать код гибким и легко изменяемым.
- Сложно заранее определить вектор изменений.
- Разделение функционала — долгая и сложная операция, нежели его объединение, поэтому отдавайте предпочтение декомпозиции. То есть старайтесь сразу создать архитектуру из небольших, независимых друг от друга сущностей.
  </script></section><section data-markdown><script type="text/template">
  Не используйте этот принцип когда:
- Заранее известно о неизменяемости кода в конкретном месте
- Решение сильно усложняет разработку и поддержку кода. Всегда нужно сохранять баланс между количеством классов и их необходимостью.
</script></section><section data-markdown><script type="text/template">

### Пример когда следовать этому принципу не нужно.

</script></section><section data-markdown><script type="text/template">

Допустим нам нужно написать класс Modem, о котором мы точно знаем что в будущем мы не будем вносить в него изменения.

```js [1-30]
class Modem {
  dial() {}
  hangup() {}
  send(request) {}
  receive() {}
}
```

</script></section><section data-markdown><script type="text/template">

Если мы будем придерживаться принципа SRP, то нам нужно будет разделить этот класс на два класса `DataChannel` для организации соединения и Connection для передачи данных.

```js [1-30]
class DataChannel {
  dial() {}
  hangup() {}
}
class Connection {
  send(request) {}
  receive() {}
}
```

Но так как мы заранее знаем, что мы никогда не будем менять класс Modem, то в данном случае все таки выгоднее оставить все как есть, иначе в будущем наш код будет иметь избыточную сложность

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Абстракция и инкапсуляция, сервисы

</script></section><section data-markdown><script type="text/template">

[Weather](https://github.com/vvscode/otus--javascript-basic/blob/0eb4ce2297ff0ef45aa60d03216166d88ebbd4a0/lessons/lesson09/lecture.md)

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Разбиение на MVC

</script></section><section data-markdown><script type="text/template">

**Разделение ответственностей** — один из основополагающих принципов инженерного дела. В частности — программной инженерии. В информатике разделение ответственностей представляет собой процесс разделения компьютерной программы на функциональные блоки, как можно меньше перекрывающие функции друг друга.

</script></section><section data-markdown><script type="text/template">

**Модель (Model)** предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.

**Представление (View)** отвечает за отображение данных модели пользователю, реагируя на изменения модели.

**Контроллер (Controller)** интерпретирует действия пользователя, оповещая модель о необходимости изменений.

</script></section><section data-markdown><script type="text/template">

<img src="./images/MVC-Process.png" title="MVC" />

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

## Компонентный подход

</script></section><section data-markdown><script type="text/template">

<img src="./images/MKC.jpg" title="MKC" />

Это международная космическая станция (МКС).

</script></section><section data-markdown><script type="text/template">

А это то, как она устроена (приблизительно):
<img src="./images/MKC_components.jpg" title="MKC" />

</script></section><section data-markdown><script type="text/template">

Международная космическая станция:

- Состоит из множества компонентов.
- Каждый компонент в свою очередь, состоит из множества более мелких деталей.
- Компоненты имеют очень сложное устройство, и гораздо сложнее большинства сайтов.
- Компоненты разработаны на международной основе, командами из разных стран и говорящих на разных языках.
</script></section><section data-markdown><script type="text/template">

### Компонентная архитектура

Хорошо известное правило разработки сложного программного обеспечения гласит: не создавай сложное программное обеспечение.

Если что-то становится сложным – раздели это на более простые части и соедини наиболее очевидным способом.

</script></section><section data-markdown><script type="text/template">

Компоненты могут содержать подкомпоненты, например сообщения могут быть частями родительского компонента «список сообщений». `Кликабельное` фото пользователя может быть самостоятельным компонентом и т.д.

</script></section><section data-markdown><script type="text/template">

Компонент имеет:

- свой собственный JavaScript-класс.
- DOM-структура управляется исключительно своим классом, и внешний код не имеет к ней доступа (принцип «инкапсуляции»).
- CSS-стили, применённые к компоненту.
- API: события, методы класса и т.п., для взаимодействия с другими компонентами.

</script></section><section data-markdown><script type="text/template">

Представим, что нам нужно реализовать простой `ToDo` лист.
<img src="./images/todolist.png" title="ToDo List" />

</script></section><section data-markdown><script type="text/template">

- Какие компоненты будут у приложения?
- Какие слои?
- Как разделить функционал?
</script></section><section data-markdown><script type="text/template">

[Код](https://codesandbox.io/s/github/acsais/otus--javascript-basic/tree/lesson25/lessons/lesson25/code)

</script></section><section data-markdown><script type="text/template">

Разберем по компонентам и слоям
[Игра жизнь](https://github.com/vvscode/otus--javascript-basic/blob/7220c09094fb760e4d25cc246d271b593d185f19/lessons/lesson20/lecture.md#%D0%B4%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D0%B5%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5)

</script></section></section><section ><section data-markdown><script type="text/template">

Дополнительные материалы:

[Shadow dom](https://learn.javascript.ru/shadow-dom)

[Пользовательские элементы](https://developer.mozilla.org/ru/docs/Web/Web_Components/Using_custom_elements)

</script></section><section data-markdown><script type="text/template">

### Опрос о занятии
</script></section></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
