<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Занятие 33</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/.reveal-md/styles.css" />


    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

# OTUS

## Javascript Basic

</script></section><section data-markdown><script type="text/template">

## Вопросы?

</script></section></section><section  data-markdown><script type="text/template">

## Mediator и EventEmitter как инструмент организации кода

</script></section><section ><section data-markdown><script type="text/template">

### Разберемся с задачей

</script></section><section data-markdown><script type="text/template">

Для начала два термина - **связность(_cohesion_)** и **связанность(_coupling_)**.

[Связность](<https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>) - на сколько составные части направлены на решение одной задачи.

[Связанность](<https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>) - на сколько одни модули зависят от других (и как много они знают друг о друге)

</script></section><section data-markdown><script type="text/template">

[Качественный дизайн обладает слабой связанностью (low coupling) и сильной связностью (high cohesion).](https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9)

Это значит, что программный компонент имеет небольшое число внешних связей и отвечает за решение близких по смыслу задач.

</script></section><section data-markdown><script type="text/template">

**Слабое зацепление (Low Coupling)** и **Высокая связность (High Cohesion)** это 2 из 9 [**шаблонов GRASP**](<https://ru.wikipedia.org/wiki/GRASP#4._%D0%A1%D0%BB%D0%B0%D0%B1%D0%BE%D0%B5_%D0%B7%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(Low_Coupling)>)

</script></section><section data-markdown><script type="text/template">

Высокая связность говорит об эффективности программы (или ее отдельных модулей).

Низкая связанность означает легкость рефакторинга и переиспользуемость кода.

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

### Наблюдатель (Observer)

</script></section><section data-markdown><script type="text/template">

[Наблюдатель](https://refactoring.guru/ru/design-patterns/observer) - подход (паттерн), позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

</script></section><section data-markdown><script type="text/template">

<img src="./images/ObservableUML.png" title="Observable UML" />

</script></section><section data-markdown><script type="text/template">

На самом деле вы с ним уже работали - это [EventTarget](https://developer.mozilla.org/ru/docs/Web/API/EventTarget)

</script></section><section data-markdown><script type="text/template">

Данный шаблон часто применяют в ситуациях, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией.

</script></section><section data-markdown><script type="text/template">

Может быть представлен как

<!-- eslint-skip -->

```ts
IObservable {
  addObserver(event, handler)
  removeObserver(event, handler)
  notifyObserver(event, data)
}
```

</script></section><section data-markdown><script type="text/template">

или

<!-- eslint-skip -->

```ts
EventTarget {
  addEventListener(event, handler)
  removeEventListener(event, handler)
  dispatchEvent(event)
}
```

</script></section><section data-markdown><script type="text/template">

или

<!-- eslint-skip -->

```ts
Backbone.Events {
  on(event, handler)
  off(event, handler)
  trigger(event)
}
```

</script></section><section data-markdown><script type="text/template">

Иногда могут добавлять вспомогательные методы, например

<!-- eslint-skip -->

```ts
Backbone.Events {
  // ...
  once(event, handler)
}
```

</script></section><section data-markdown><script type="text/template">

```ts
document.querySelector(element).addEventListener("click", (ev) => {
  alert("Boom!");
});
```

</script></section><section data-markdown><script type="text/template">

Оговорка: чаще всего обработчиком события является функция. Но это также может быть и объект ([EventListener](https://developer.mozilla.org/ru/docs/Web/API/EventListener)) - в зависимости от реализации.

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

### Посредник (Mediator)

</script></section><section data-markdown><script type="text/template">

[Посредник](https://refactoring.guru/ru/design-patterns/mediator) - это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

</script></section><section data-markdown><script type="text/template">

**Задача:** Обеспечить взаимодействие множества объектов, сформировав при этом слабую связанность и избавив объекты от необходимости явно ссылаться друг на друга.

**Решение:** Создать объект, инкапсулирующий способ взаимодействия множества объектов.

**Преимущества:** Устраняется связанность между "Коллегами", централизуется управление.

</script></section><section data-markdown><script type="text/template">

Самый распространенный (и простой) вариант реализации паттерна - с использованием **EventEmitter** интерфейса (**Event Bus** - Шина событий).

</script></section><section data-markdown><script type="text/template">

Разница, по сравнению с обычным использованием EventTarget:

- события в EventTarget генерирует сам объект, при работе с EventBus это делают сторонние объекты
- список событий при работе с EventTarget ограничен устройством объекта, при работе с EventBus он определяется участниками

</script></section><section data-markdown><script type="text/template">

<img src="./images/EventBus.jpeg" title="Event Bus" />

</script></section><section data-markdown><script type="text/template">

При этом, чтобы избежать коллизии имен событий, зачастую вводят `namespaces`, в формате **{NAMESPACE}:{EVENT NAME}**. Например `user:add`, `searchHistory:add`.

Нужно отметить, что по-хорошему, префиксы делаются на основе сущностей, а не на основе модулей (иначе происходит раскрытие структуры системы).

</script></section><section data-markdown><script type="text/template">

```ts
const eventBus = new EventBus();

// module 1
eventBus.on("city:changed", (cityName) => console.log(`New city: ${cityName}`));

// module 2
eventBus.trigger("city:changed", "Minsk");
```

</script></section><section data-markdown><script type="text/template">

Как мы могли бы применить это к уже сделанным домашним заданиям?

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

### Практика

</script></section><section data-markdown><script type="text/template">

[Реализовать Event Emitter](https://codesandbox.io/s/github/vvscode/otus--javascript-basic/tree/master/lessons/lesson33/code/eventEmitter)

</script></section><section data-markdown><script type="text/template">

Реализовать поверх существующего функционала метод **once** (для одноразового вызова обработчика).

</script></section><section data-markdown><script type="text/template">

### Вопросы?

</script></section></section><section ><section data-markdown><script type="text/template">

Дополнительные материалы:

- [Backbone Events](https://backbonejs.org/#Events) и [исходники](https://backbonejs.org/docs/backbone.html#section-17)
- [EventTarget simple implementation](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)
- [Паттерны проектирования понятным языком](https://refactoring.guru/ru/design-patterns)
- [Design patterns for humans!](https://github.com/sohamkamani/javascript-design-patterns-for-humans)

</script></section><section data-markdown><script type="text/template">

### Опрос о занятии
</script></section></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"hash":true,"history":false,"backgroundTransition":"fade","width":"80%","tableofcontents":{"title":"План","position":1000}}, queryOptions);
    </script>

    <script src="./../_assets/plugins.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
